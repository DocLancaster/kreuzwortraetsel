<!DOCTYPE html>
<html lang="de">
<head>
  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3204938762614599"
     crossorigin="anonymous"></script>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>
  <title>Kreuzwortr√§tsel</title>
  <link rel="stylesheet" href="style.css">
  <style>
  #confetti-container {
    pointer-events: none;
    position: fixed;
    top: 0; left: 0; width: 100vw; height: 100vh;
    z-index: 9999;
    overflow: hidden;
  }
  .confetti-piece {
    position: absolute;
    width: 12px;
    height: 18px;
    border-radius: 3px;
    opacity: 0.85;
    will-change: transform;
    pointer-events: none;
    animation: confetti-fall 1.5s linear forwards;
  }
  @keyframes confetti-fall {
    0% {
      transform: translateY(-20vh) rotate(0deg);
      opacity: 1;
    }
    90% {
      opacity: 1;
    }
    100% {
      transform: translateY(110vh) rotate(360deg);
      opacity: 0;
    }
  }
  /* Rating modal */
  .modal-overlay { position: fixed; inset: 0; background: rgba(0,0,0,.5); display:none; align-items:center; justify-content:center; z-index: 10000; min-height: 100vh; padding: 12px; }
  .modal { background:#fff; max-width: 420px; width: calc(100% - 32px); border-radius: 12px; box-shadow: 0 10px 30px rgba(0,0,0,.2); padding: 18px; max-height: 90vh; overflow:auto; }
  .modal h2 { margin: 0 0 8px; font-size: 20px; }
  .modal p { margin: 0 0 12px; color:#555; }
  .stars { display:flex; gap:8px; justify-content:center; padding: 8px 0 12px; }
  .stars button { appearance:none; border:none; background:none; cursor:pointer; font-size: 28px; line-height:1; padding:4px; min-width:44px; min-height:44px; }
  .star { color:#ccc; transition: transform .08s ease, color .08s ease; }
  .star.hover, .star.selected { color: #f5b301; transform: scale(1.05); }
  .modal .actions { display:flex; gap:10px; justify-content:flex-end; margin-top: 10px; }
  .modal .actions button { padding: 8px 12px; border:none; border-radius:8px; cursor:pointer; }
  .btn-secondary { background:#eee; }
  .btn-primary { background:#007bff; color:#fff; opacity:.6; }
  .btn-primary.enabled { opacity:1; }

  /* Better mobile sizing & safe areas */
  @supports (height: 100dvh) {
    .modal-overlay { min-height: 100dvh; }
    .modal { max-height: 90dvh; }
  }

  @media (max-width: 480px) {
    .modal { width: calc(100% - 24px); padding: 16px; }
    .stars { gap: 10px; }
    .stars button { font-size: 36px; padding: 8px; }
    .modal .actions { flex-direction: column; }
    .modal .actions button { width: 100%; padding: 12px; font-size: 16px; }
  }
  /* Personal Score HUD */
  .user-hud { text-align:center; margin:.35rem 0 .2rem; font-size:.95rem; color: var(--muted); position: relative; }
  @media (max-width: 480px){ .user-hud{ font-size:.9rem; } }
  .user-hud .coins{ display:inline-flex; align-items:center; gap:6px; justify-content:center; font-weight:700; color: var(--text); }
  .user-hud .coin-icon{
    position: relative;
    width:18px; height:18px; border-radius:50%; display:inline-block;
    background:
      radial-gradient(circle at 35% 35%, #fff59d 0%, #fde047 35%, #f59e0b 65%, #b45309 100%),
      conic-gradient(from 200deg, rgba(255,255,255,.25), rgba(0,0,0,.05) 120deg, rgba(255,255,255,.2) 180deg, rgba(0,0,0,.08) 240deg, rgba(255,255,255,.25));
    box-shadow:
      inset 0 1px 0 rgba(255,255,255,.5),
      inset 0 0 0 1px rgba(0,0,0,.12),
      0 1px 1px rgba(0,0,0,.08);
  }
  /* Gloss & sparkle */
  .user-hud .coin-icon::before{
    content:""; position:absolute; inset:2px 2px 6px 6px; border-radius:50%;
    background: radial-gradient(circle at 30% 30%, rgba(255,255,255,.75), rgba(255,255,255,0) 60%);
    pointer-events:none;
  }
  .user-hud .coin-icon::after{
    content:""; position:absolute; left:4px; top:3px; width:3px; height:3px; border-radius:50%;
    background: rgba(255,255,255,.9); filter: blur(.2px); opacity:.9; pointer-events:none;
  }
  /* subtle burst animation when coins increase */
  @keyframes coin-burst{ 0%{ transform:scale(1); } 30%{ transform:scale(1.15); } 60%{ transform:scale(1.02);} 100%{ transform:scale(1);} }
  .user-hud .coin-icon.burst{ animation: coin-burst .35s ease-out; }
  @media (max-width:480px){ .user-hud .coin-icon{ width:16px; height:16px; } }
  .user-hud .coin-fly{
  position:absolute;
  left:50%;
  transform: translateX(-50%);
  bottom:-4px;
  font-weight:800;
  color:#16a34a;
  text-shadow: 0 1px 0 rgba(0,0,0,.2);
  opacity:0;
  pointer-events:none;
  animation: flyCoin .9s ease-out forwards;
}
@keyframes flyCoin{
  0%{ transform: translate(-50%, 8px) scale(.9); opacity:0; }
  20%{ opacity:1; }
  100%{ transform: translate(-50%, -22px) scale(1.05); opacity:0; }
}
@media (prefers-color-scheme: dark){
  .user-hud .coin-fly{ color:#22c55e; text-shadow: 0 1px 0 rgba(0,0,0,.6); }
}
@media (prefers-color-scheme: dark){
  .user-hud .coins{ color:#e5e7eb; }
  .user-hud .coin-icon{ box-shadow: inset 0 1px 0 rgba(255,255,255,.12), inset 0 0 0 1px rgba(0,0,0,.55), 0 1px 1px rgba(0,0,0,.45); }
}
  </style>
</head>
<body>
  <div class="back-to-menu">
    <button onclick="window.location.href='index.html'">‚Üê Hauptmen√º</button>
  </div>
  <div class="card">
  <h1>Kreuzwortr√§tsel</h1>
  <div id="userHud" class="user-hud" aria-live="polite"></div>

  <!-- Prev/Next + Hinweis -->
  <div class="navigation">
    <button id="prevWord" title="Vorheriges Wort">
      <svg xmlns="http://www.w3.org/2000/svg" class="icon" viewBox="0 0 16 16" fill="currentColor">
        <path fill-rule="evenodd" d="M11.354 1.146a.5.5 0 0 1 0 .708L5.707 7.5l5.647 5.646a.5.5 0 0 1-.708.708l-6-6a.5.5 0 0 1 0-.708l6-6a.5.5 0 0 1 .708 0z"/>
      </svg>
    </button>
    <div id="currentClue" class="clue-text" role="status" aria-live="polite"></div>
    <button id="nextWord" title="N√§chstes Wort">
      <svg xmlns="http://www.w3.org/2000/svg" class="icon" viewBox="0 0 16 16" fill="currentColor">
        <path fill-rule="evenodd" d="M4.646 1.146a.5.5 0 0 0 0 .708L10.293 8l-5.647 5.646a.5.5 0 0 0 .708.708l6-6a.5.5 0 0 0 0-.708l-6-6a.5.5 0 0 0-.708 0z"/>
      </svg>
    </button>
  </div>

  <!-- Grid mit Inline-Hinweisen -->
  <div class="grid" id="grid"></div>

  <!-- Controls -->
  <div class="controls">
    <button class="control check" onclick="checkSolution()">L√∂sung pr√ºfen</button>
    <button class="control hint" id="revealBtn">Hinweis (3)</button>
    <button class="control reset" id="resetBtn">Neu starten</button>
    <button class="control new" onclick="window.removeEventListener('beforeunload', saveState); localStorage.removeItem(RAEETSEL_STORAGE_KEY); window.location.reload();">Neues R√§tsel generieren</button>
    <button id="flagBtn" class="control flag">üö© Wort melden</button>
  </div>

  </div>
  <!-- Rating Modal -->
  <div id="ratingModal" class="modal-overlay" role="dialog" aria-modal="true" aria-labelledby="ratingTitle">
    <div class="modal">
      <h2 id="ratingTitle">üéâ R√§tsel gel√∂st!</h2>
      <p>Wie viele Sterne gibst du diesem R√§tsel?</p>
      <div class="stars" id="ratingStars" aria-label="Sternebewertung">
        <button type="button" class="star" data-value="1" aria-label="1 Stern">‚òÖ</button>
        <button type="button" class="star" data-value="2" aria-label="2 Sterne">‚òÖ</button>
        <button type="button" class="star" data-value="3" aria-label="3 Sterne">‚òÖ</button>
        <button type="button" class="star" data-value="4" aria-label="4 Sterne">‚òÖ</button>
        <button type="button" class="star" data-value="5" aria-label="5 Sterne">‚òÖ</button>
      </div>
      <div class="actions">
        <button id="ratingSkip" class="btn-secondary" type="button">√úberspringen</button>
        <button id="ratingSend" class="btn-primary" type="button" disabled>Bewerten</button>
      </div>
    </div>
  </div>
  <div id="resultModal" class="modal-overlay" role="dialog" aria-modal="true" aria-labelledby="resultTitle" style="display:none">
  <div class="modal">
    <h2 id="resultTitle">Ergebnis</h2>
    <p id="resultSummary" style="margin-top:6px; margin-bottom:12px; font-weight:600;"></p>
    <div class="actions">
      <button id="resultNew" class="btn-primary enabled" type="button">Neues R√§tsel generieren</button>
      <button id="resultClose" class="btn-secondary" type="button">Schlie√üen</button>
    </div>
  </div>
</div>
  <script>
    function showConfetti() {
      const container = document.getElementById('confetti-container');
      const colors = ["#ffc107", "#28a745", "#007bff", "#dc3545", "#ff69b4", "#00bcd4", "#fff", "#fd7e14"];
      for (let i = 0; i < 50; i++) {
        const div = document.createElement("div");
        div.className = "confetti-piece";
        div.style.background = colors[Math.floor(Math.random() * colors.length)];
        div.style.left = Math.random() * 100 + "vw";
        div.style.top = (Math.random() * 10 - 10) + "vh";
        div.style.transform = `rotate(${Math.random() * 360}deg)`;
        div.style.animationDelay = (Math.random() * 0.4) + "s";
        container.appendChild(div);
        setTimeout(() => container.removeChild(div), 1800);
      }
    }
    const gridSize = 10;

    // Grid-Daten und State
    let grid = Array(gridSize).fill(null).map(() => Array(gridSize).fill(null));
    let words = [];
    let currentWordIndex = 0;
    let currentDirection = 'horizontal';
    let lastFocusedCell = null;
    let userClicked = false;
let checksCount = 0;           // how often "L√∂sung pr√ºfen" gedr√ºckt wurde
let wrongCellsChecked = 0;     // Summe falsch markierter Felder √ºber alle Checks
let puzzleStart = performance.now();
let wordsCount = 0;
let lettersCount = 0;
let lastSubmitResult = null;
let lastCoinsShown = null;
let revealsLeft = 3;

// Puzzle-/Theme-Auswahl per URL-Parameter
const params = new URLSearchParams(location.search);
const puzzleType = params.get('puzzle') || 'classic';
const themesParam = params.get('themes');           // z.B. "reise,jura"
const excludeParam = params.get('exclude');         // z.B. "marken,abkuerzungen"

// Eine Datei f√ºr alle W√∂rter ‚Äì Filter via Themes
const puzzleConfig = {
  classic:       { title: 'Kreuzwortr√§tsel',                  themes: null },
  jura:          { title: 'Jura-Kreuzwortr√§tsel',             themes: ['jura'] },
  reisesspecial: { title: 'Reise-Special Kreuzwortr√§tsel',    themes: ['reise'] }
};

const BASE_WORDS_FILE = 'words.json';
const cfg = puzzleConfig[puzzleType] || puzzleConfig.classic;

// Aus URL (themes=...) kann die Auswahl √ºberschreiben/erg√§nzen
let includeThemes = Array.isArray(cfg.themes) ? [...cfg.themes] : null;
if (themesParam) {
  const parsed = themesParam.split(',').map(s => s.trim().toLowerCase()).filter(Boolean);
  includeThemes = parsed.length ? parsed : null;
}
let excludeThemes = null;
if (excludeParam) {
  excludeThemes = excludeParam.split(',').map(s => s.trim().toLowerCase()).filter(Boolean);
  if (!excludeThemes.length) excludeThemes = null;
}

// Titel ableiten
let puzzleTitle = cfg.title || 'Kreuzwortr√§tsel';
if (themesParam) {
  const label = themesParam.split(',').map(s => s.trim()).filter(Boolean).join(', ');
  if (label) puzzleTitle = `Kreuzwortr√§tsel (${label})`;
}

// Dynamischer Dokument- und √úberschrift-Titel
document.title = puzzleTitle;
document.querySelector('.card > h1').textContent = puzzleTitle;

// Eindeutiger Key pro Variante (inkl. Themes), damit LocalStorage nicht kollidiert
const themeKey = includeThemes ? includeThemes.join('-') : 'all';
const excludeKey = excludeThemes ? ('_x-' + excludeThemes.join('-')) : '';
const RAEETSEL_STORAGE_KEY = `${location.pathname.split('/').pop()}_${puzzleType}_${themeKey}${excludeKey}`;
// Stable per-user id (stored locally), honors ?uid= and keeps both keys in sync
function getUserId() {
  const KEY_NEW = 'USER_ID';
  const KEY_OLD = 'puzzle_user_id_v1';
  const params = new URLSearchParams(location.search);
  const fromUrl = params.get('uid');
  let id = fromUrl || localStorage.getItem(KEY_NEW) || localStorage.getItem(KEY_OLD);
  if (!id) {
    const arr = new Uint8Array(16);
    (window.crypto || window.msCrypto).getRandomValues(arr);
    id = Array.from(arr, b => b.toString(16).padStart(2,'0')).join('');
  }
  // persist to both keys for cross-page compatibility
  try { localStorage.setItem(KEY_NEW, id); } catch(_) {}
  try { localStorage.setItem(KEY_OLD, id); } catch(_) {}
  return id;
}
const USER_ID = getUserId();
// --- stable IDs for words (fallback if JSON has no id) ---
function fnv1a(str){
  let h = 0x811c9dc5;
  for (let i = 0; i < str.length; i++) {
    h ^= str.charCodeAt(i);
    h += (h << 1) + (h << 4) + (h << 7) + (h << 8) + (h << 24);
  }
  return h >>> 0;
}
function makeWordId(word){
  const base = (word || '').toUpperCase().trim();
  return 'w' + fnv1a(base).toString(36);
}
function ensureIds(list){
  return list.map(w => ({ ...w, id: w.id || makeWordId(w.word) }));
}
// --- end id helpers ---
// --- Rating modal helpers ---
let ratingSelected = 0;
let completionHandled = false;

function openRatingModal() {
  return new Promise(resolve => {
    const overlay = document.getElementById('ratingModal');
    const stars = Array.from(document.querySelectorAll('#ratingStars .star'));
    const btnSkip = document.getElementById('ratingSkip');
    const btnSend = document.getElementById('ratingSend');

    ratingSelected = 0;
    btnSend.disabled = true; btnSend.classList.remove('enabled');
    stars.forEach(s => s.classList.remove('selected','hover'));

    const setVisual = (n) => {
      stars.forEach(st => {
        const v = Number(st.dataset.value);
        st.classList.toggle('selected', v <= n);
      });
      ratingSelected = n;
      if (ratingSelected > 0) { btnSend.disabled = false; btnSend.classList.add('enabled'); }
      else { btnSend.disabled = true; btnSend.classList.remove('enabled'); }
    };

    const onEnter = (e)=>{ const v = Number(e.currentTarget.dataset.value); stars.forEach(st=>st.classList.toggle('hover', Number(st.dataset.value) <= v)); };
    const onLeave = ()=>{ stars.forEach(st=>st.classList.remove('hover')); };
    const onClick = (e)=>{ setVisual(Number(e.currentTarget.dataset.value)); };

    stars.forEach(st => {
      st.addEventListener('mouseenter', onEnter);
      st.addEventListener('mouseleave', onLeave);
      st.addEventListener('click', onClick);
    });

    const cleanup = () => {
      stars.forEach(st => {
        st.removeEventListener('mouseenter', onEnter);
        st.removeEventListener('mouseleave', onLeave);
        st.removeEventListener('click', onClick);
      });
      btnSkip.removeEventListener('click', onSkip);
      btnSend.removeEventListener('click', onSend);
      overlay.style.display = 'none';
      document.body.style.overflow = '';
    };

    const onSkip = () => { cleanup(); resolve(null); };
    const onSend = () => { if (ratingSelected>0) { cleanup(); resolve(ratingSelected); } };

    btnSkip.addEventListener('click', onSkip);
    btnSend.addEventListener('click', onSend);

    overlay.style.display = 'flex';
    document.body.style.overflow = 'hidden';
  });
}

async function submitPuzzleRating(stars) {
  try {
    await Promise.all(
      words.map(w => fetch('/api/rate', {
        method: 'POST', headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ puzzle: puzzleType, word: w.word, id: w.id, rating: Number(stars) })
      }))
    );
  } catch(_) {}
}

function showResultModal(){
  try{
    const m = document.getElementById('resultModal');
    const p = document.getElementById('resultSummary');
    const data = lastSubmitResult || {};
    const score = typeof data.score === 'number' ? data.score : computeClientScore();
    const coinsEarned = typeof data.coinsEarned === 'number' ? data.coinsEarned : Math.floor(score/10);
    p.textContent = `Score: ${score} ‚Ä¢ M√ºnzen: +${coinsEarned}`;
    m.style.display = 'flex';
    document.body.style.overflow = 'hidden';
    const btnClose = document.getElementById('resultClose');
    const btnNew = document.getElementById('resultNew');
        btnClose.onclick = () => {
      m.style.display = 'none';
      document.body.style.overflow = '';
      popCoinGain(coinsEarned);
    };
    btnNew.onclick = () => {
      m.style.display = 'none';
      document.body.style.overflow = '';
      popCoinGain(coinsEarned);
      setTimeout(() => {
        window.removeEventListener('beforeunload', saveState);
        localStorage.removeItem(RAEETSEL_STORAGE_KEY);
        window.location.reload();
      }, 650);
    };
  }catch(_){ }
}

async function handlePuzzleCompleted() {
  if (completionHandled) return; // prevent double-trigger
  completionHandled = true;
  showConfetti();
  setTimeout(async () => {
    const stars = await openRatingModal();
if (stars && Number(stars) >= 1) {
  await submitPuzzleRating(stars);
}
showResultModal();
  }, 600);
}
// --- end rating modal helpers ---

    // Wortliste wird extern geladen
    let wordList = [];
    function saveState() {
      const userInputs = {};
      document.querySelectorAll("input.cell:not(.black)").forEach(input => {
        const r = input.dataset.row;
        const c = input.dataset.col;
        userInputs[`${r},${c}`] = input.value.toUpperCase();
      });
      const state = { grid, words, revealsLeft, currentWordIndex, currentDirection, userInputs };
      localStorage.setItem(RAEETSEL_STORAGE_KEY, JSON.stringify(state));    }

    function loadState() {
    const s = localStorage.getItem(RAEETSEL_STORAGE_KEY);      
    return s ? JSON.parse(s) : null;
    }

    // Fisher‚ÄìYates shuffle for unbiased randomization
    function shuffleArray(arr) {
      for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
      return arr;
    }

    // W√§hlt `count` zuf√§llige Eintr√§ge aus
    function getRandomWords(count) {
      return shuffleArray([...wordList]).slice(0, count);
    }

    // Intelligente Platzierung von W√∂rtern
    function generateWords() {
      // Randomize word list
      const shuffled = shuffleArray([...wordList]);
      // Prepare unplaced words
      let unplaced = shuffled.slice();
      // Initialize empty test grid
      const testGrid = Array(gridSize).fill(null).map(() => Array(gridSize).fill(null));
      const placed = [];

      // Place first word centered horizontally, ensure it fits within grid
      // Find the first word whose length does not exceed gridSize
      const firstIdx = unplaced.findIndex(item => item.word.length <= gridSize);
      if (firstIdx === -1) {
        // No fitting word found; abort generation
        words = [];
        return;
      }
      const first = unplaced.splice(firstIdx, 1)[0];
      const sx = Math.floor((gridSize - first.word.length) / 2);
      const sy = Math.floor(gridSize / 2);
      for (let i = 0; i < first.word.length; i++) {
        testGrid[sy][sx + i] = first.word[i];
      }
      placed.push({ id: first.id, word: first.word, x: sx, y: sy, horizontal: true, clue: first.clue });
      // Block cells directly before and after the first word
      const firstEndX = sx + first.word.length - 1;
      const barrierPositionsFirst = [
        { r: sy, c: sx - 1 },
        { r: sy, c: firstEndX + 1 }
      ];
      barrierPositionsFirst.forEach(pos => {
        if (
          pos.r >= 0 && pos.r < gridSize &&
          pos.c >= 0 && pos.c < gridSize &&
          testGrid[pos.r][pos.c] === null
        ) {
          testGrid[pos.r][pos.c] = "*";
        }
      });

      // Place remaining words by choosing the one with highest overlaps
      while (true) {
        let bestPlacement = null;
        let bestScore = 0;
        let bestWordIndex = -1;

        // Evaluate each unplaced word
        for (let wIdx = 0; wIdx < unplaced.length; wIdx++) {
          const { word, clue } = unplaced[wIdx];
          let localBestScore = 0;
          let localBestPlacement = null;

          // Try both orientations
          for (const hor of [true, false]) {
            for (let row = 0; row < gridSize; row++) {
              for (let col = 0; col < gridSize; col++) {
                const startX = col;
                const startY = row;
                const endX = hor ? col + word.length - 1 : col;
                const endY = hor ? row : row + word.length - 1;
                // Bounds
                if (endX >= gridSize || endY >= gridSize) continue;

                let collision = false;
                let score = 0;
                for (let k = 0; k < word.length; k++) {
                  const r = hor ? startY : startY + k;
                  const c = hor ? startX + k : startX;
                  const cell = testGrid[r][c];
                  if (cell === "*") { collision = true; break; }
                  if (cell === word[k]) score++;
                  else if (cell !== null) { collision = true; break; }
                }
                if (collision || score === 0) continue;

                // Adjacency before/after
                const before = hor
                  ? { r: startY, c: startX - 1 }
                  : { r: startY - 1, c: startX };
                const after = hor
                  ? { r: startY, c: endX + 1 }
                  : { r: endY + 1, c: startX };
                if (
                  (before.r >= 0 && before.r < gridSize && before.c >= 0 && before.c < gridSize &&
                    testGrid[before.r][before.c] !== null && testGrid[before.r][before.c] !== '*'
                  ) ||
                  (after.r  >= 0 && after.r  < gridSize && after.c  >= 0 && after.c  < gridSize &&
                    testGrid[after.r][after.c] !== null && testGrid[after.r][after.c] !== '*'
                  )
                ) continue;

                if (score > localBestScore) {
                  localBestScore = score;
                  localBestPlacement = { startX, startY, horizontal: hor };
                }
              }
            }
          }

          if (localBestPlacement && localBestScore > bestScore) {
            bestScore = localBestScore;
            bestPlacement = localBestPlacement;
            bestWordIndex = wIdx;
          }
        }

        // Stop if no valid placement remains
        if (!bestPlacement) break;

        // Commit best placement
        const { id, word, clue } = unplaced[bestWordIndex];
        const { startX, startY, horizontal: hor } = bestPlacement;
        for (let k = 0; k < word.length; k++) {
          const r = hor ? startY : startY + k;
          const c = hor ? startX + k : startX;
          testGrid[r][c] = word[k];
        }
        placed.push({ id, word, x: startX, y: startY, horizontal: hor, clue });

        // Barrier before/after
        const endX = hor ? startX + word.length - 1 : startX;
        const endY = hor ? startY : startY + word.length - 1;
        const barrierPositions = hor
          ? [ { r: startY, c: startX - 1 }, { r: startY, c: endX + 1 } ]
          : [ { r: startY - 1, c: startX }, { r: endY + 1, c: startX } ];
        barrierPositions.forEach(pos => {
          if (
            pos.r >= 0 && pos.r < gridSize &&
            pos.c >= 0 && pos.c < gridSize &&
            testGrid[pos.r][pos.c] === null
          ) {
            testGrid[pos.r][pos.c] = "*";
          }
        });

        // Remove placed word from unplaced
        unplaced.splice(bestWordIndex, 1);
      }

      // Commit testGrid to real grid
      for (let r = 0; r < gridSize; r++) {
        grid[r] = testGrid[r].slice();
      }
      words = placed;
      // Stats for scoring
      wordsCount = words.length;
      lettersCount = 0;
      for (let r = 0; r < gridSize; r++) {
        for (let c = 0; c < gridSize; c++) {
          if (grid[r][c] !== null && grid[r][c] !== '*') lettersCount++;
        }
      }
    }


    // Lade externe Wortliste und initialisiere das R√§tsel
    // (wird nach generateWords() eingef√ºgt)

    // Beispiel f√ºr die Verwendung von shuffleArray an anderer Stelle:
    // In einer Funktion wie findeLoesungswort (falls vorhanden):
    // const worte = shuffleArray([...wordList]);

    function msToMMSS(ms){
      const s = Math.floor(ms/1000); const m = Math.floor(s/60); const r = s%60;
      return `${String(m).padStart(2,'0')}:${String(r).padStart(2,'0')}`;
    }
    function computeClientScore(){
      const durationMs = Math.max(0, (performance.now() - puzzleStart));
      const revealsUsed = Math.max(0, 3 - revealsLeft);
      const timePenalty = Math.min(40, durationMs / 3000);
      const revealPenalty = 8 * revealsUsed;
      const errorPenalty = 0.5 * wrongCellsChecked;
      const sizeBonus = Math.min(10, (lettersCount||0) / 30);
      const raw = 100 - timePenalty - revealPenalty - errorPenalty + sizeBonus;
      return Math.max(0, Math.min(100, Math.round(raw)));
    }
    async function updateUserHud(){
      try{
        const r = await fetch('/api/user-score', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ userId: USER_ID }) });
        if(!r.ok) return;
        const data = await r.json();
        const t = data.totals || {};
        const hud = document.getElementById('userHud');
        const prevCoins = (lastCoinsShown === null) ? null : lastCoinsShown;
        hud.innerHTML = `<span class="coins"><span class="coin-icon" aria-hidden="true"></span><span id="coinCount">${t.coins ?? 0}</span></span>`;
        const nowCoins = (t.coins ?? 0);
        if (prevCoins !== null && nowCoins > prevCoins) {
          const icon = hud.querySelector('.coin-icon');
          if (icon) {
            icon.classList.add('burst');
            setTimeout(() => icon.classList.remove('burst'), 400);
          }
        }
        lastCoinsShown = nowCoins;
            }catch(_){ /* noop */ }
    }

    function popCoinGain(amount){
      if (!amount || amount <= 0) return;
      const hud = document.getElementById('userHud');
      if (!hud) return;
      const el = document.createElement('span');
      el.className = 'coin-fly';
      el.textContent = `+${amount}`;
      hud.appendChild(el);
      setTimeout(() => { if (el && el.parentNode) el.parentNode.removeChild(el); }, 1000);
    }
    async function submitUserProgress(){
      const payload = {
        userId: USER_ID,
        puzzle: puzzleType,
        themes: Array.isArray(includeThemes)? includeThemes : [],
        durationMs: Math.max(0, Math.floor(performance.now() - puzzleStart)),
        revealsUsed: Math.max(0, 3 - revealsLeft),
        checks: checksCount,
        wrongCells: wrongCellsChecked,
        wordsCount,
        lettersCount,
        puzzleScore: computeClientScore(),
        completedAt: Date.now()
      };
      try{
        const r = await fetch('/api/user-submit', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(payload) });
        if(r.ok){ const data = await r.json(); lastSubmitResult = data; await updateUserHud(); return data; }
      }catch(_){ }
      return null;
    }
    // L√∂sungspr√ºfung
    function checkSolution() {
      checksCount++;
      let wrongNow = 0;
      const inputs = document.querySelectorAll("input.cell:not(.black)");
      let allCorrect = true;
      inputs.forEach(input => {
        const r = parseInt(input.dataset.row, 10);
        const c = parseInt(input.dataset.col, 10);
        const expected = ('' + grid[r][c]).toUpperCase();
        const actual = input.value.toUpperCase();
        if (input.value === "") {
          // Leere Zellen unmarkiert lassen
          input.style.backgroundColor = "";
          allCorrect = false;
        } else if (actual === expected) {
          input.style.backgroundColor = "#c8f7c5"; // correct = green
        } else {
          input.style.backgroundColor = "#f7c5c5"; // incorrect = red
          wrongNow++;
          allCorrect = false;
        }
      });
      wrongCellsChecked += wrongNow;
      if (allCorrect) {
        submitUserProgress().then(updateUserHud).catch(()=>{});
        handlePuzzleCompleted();
      } else {
        alert("‚ùå Einige Felder sind noch falsch. Versuch‚Äôs nochmal!");
      }
    }

    async function checkAutoSuccess() {
      const inputs = document.querySelectorAll("input.cell:not(.black)");
      let allCorrect = true;
      for (const input of inputs) {
        const r = parseInt(input.dataset.row, 10);
        const c = parseInt(input.dataset.col, 10);
        if ((input.value || '').toUpperCase() !== grid[r][c]) {
          allCorrect = false;
          break;
        }
      }
      if (allCorrect) {
        inputs.forEach(input => { input.style.backgroundColor = "#c8f7c5"; });
        handlePuzzleCompleted();
        submitUserProgress().then(updateUserHud).catch(()=>{});
        return true;
      }
      return false;
    }

// Lade externe Wortliste und initialisiere das R√§tsel
fetch(`/${BASE_WORDS_FILE}`)
      .then(res => res.json())
      .then(async data => {
        wordList = ensureIds(data);
        // Remove duplicate words (keep first occurrence)
        const seenWords = new Set();
        wordList = wordList.filter(item => {
          if (seenWords.has(item.word)) return false;
          seenWords.add(item.word);
          return true;
        });
        // --- Theme-Filter anwenden ---
        const normThemes = (w) => Array.isArray(w.themes) ? w.themes.map(s => String(s).toLowerCase()) : [];

        if (includeThemes && includeThemes.length) {
          const filtered = wordList.filter(w => {
            const t = normThemes(w);
            return t.length && t.some(tag => includeThemes.includes(tag));
          });
          // Falls zu wenige √ºbrig bleiben (z. B. neues Special), auf alle W√∂rter zur√ºckfallen
          if (filtered.length >= 10) {
            wordList = filtered;
          } else {
            console.warn('Theme-Filter zu streng, benutze alle W√∂rter');
          }
        }
        if (excludeThemes && excludeThemes.length) {
          wordList = wordList.filter(w => {
            const t = normThemes(w);
            return !t.some(tag => excludeThemes.includes(tag));
          });
        }
        // --- Ende Theme-Filter ---
        // --- Fetch feedback metrics from server and compute scores ---
        try {
          const resMetrics = await fetch('/api/metrics', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              puzzle: puzzleType,
              words: wordList.map(w => w.word),
              ids:   wordList.map(w => w.id)
            })
          });
          if (resMetrics.ok) {
            const metrics = await resMetrics.json();
            const prior = 4.0;      // Grundannahme: gutes Wort (0..5)
            const weight = 10;      // St√§rke der Vorannahme
            wordList.forEach(w => {
              const m        = metrics[w.word] || {};
              const sum      = Number(m.ratingSum   || 0);
              const count    = Number(m.ratingCount || 0);
              const appear   = Number(m.appear      || 0);
              const flags    = Number(m.flags       || 0);
              const flagRate = appear > 0 ? (flags / appear) : 0; // 0..1
              const trust    = Math.min(count / 50, 1); // 0..1
              const bayesAvg = (prior * weight + sum) / (weight + count); // 0..5
              // Score: Bayes-√ò gewichtet mit Vertrauen, Flag-Rate zieht ab
              w.score = bayesAvg * (0.6 + 0.2 * trust) - 2.0 * flagRate;
              // Exploration: etwas Zufall, st√§rker bei wenig Vertrauen
              const exploreBase = 0.15;                 // immer etwas Variabilit√§t
              const explore = exploreBase + (1 - trust) * 0.35; // 0.15..0.5
              w.rank = (w.score || 0) + explore * Math.random();
            });
            // Demote words currently in per-user cooldown, then sort by rank
            try {
              const resCd = await fetch('/api/cooldown-get', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                  userId: USER_ID,
                  puzzle: puzzleType,
                  words: wordList.map(w => w.word),
                  ids:   wordList.map(w => w.id)
                })
              });
              if (resCd.ok) {
                const { map } = await resCd.json();
                const available = [];
                const cooled = [];
                for (const w of wordList) {
                const hit = map ? (map[w.id] ?? map[w.word]) : undefined;
                (hit ? cooled : available).push(w);
              }
                wordList = available.concat(cooled);
              }
            } catch(_) {}
            // final sort by rank among the merged list
            wordList.sort((a, b) => (b.rank || 0) - (a.rank || 0));
          } else {
            console.warn('metrics endpoint failed', resMetrics.status);
          }
        } catch (err) {
          console.warn('metrics fetch error', err);
        }
        // --- end metrics scoring ---
        const saved = loadState();
        if (saved) {
          saved.grid.forEach((row, i) => { grid[i] = saved.grid[i]; });
          words = saved.words;
          revealsLeft = saved.revealsLeft;
          currentWordIndex = saved.currentWordIndex;
          currentDirection = saved.currentDirection;
        } else {
          generateWords();
          // einmalig Appearances z√§hlen und per-user Cooldown setzen (24h)
          try {
            const unique = [...new Set(words.map(w => w.word))];
            const uniqueIds   = [...new Set(words.map(w => w.id))];
            const uniqueWords = [...new Set(words.map(w => w.word))];
            fetch('/api/appearance', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ puzzle: puzzleType, ids: uniqueIds, words: uniqueWords })
            }).catch(() => {});
            fetch('/api/cooldown-set', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ userId: USER_ID, puzzle: puzzleType, ids: uniqueIds, words: uniqueWords, ttlSeconds: 86400 })
            }).catch(() => {});
          } catch (e) {}
          saveState();
        }

        const gridContainer = document.getElementById("grid");

        const revealBtn = document.getElementById("revealBtn");
        revealBtn.addEventListener("click", () => {
          if (revealsLeft <= 0) return;
          const cell = lastFocusedCell;
          if (
            cell &&
            cell.tagName === "INPUT" &&
            cell.classList.contains("cell") &&
            !cell.classList.contains("black") &&
            cell.value === ""
          ) {
            const r = parseInt(cell.dataset.row);
            const c = parseInt(cell.dataset.col);
            cell.value = grid[r][c];
            cell.style.backgroundColor = "#c8f7c5";
            revealsLeft--;
            revealBtn.textContent = `Hinweis (${revealsLeft})`;
            if (revealsLeft === 0) revealBtn.disabled = true;
          }
          saveState();
        });

        const resetBtn = document.getElementById('resetBtn');
        resetBtn.addEventListener('click', () => {
          // Clear saved state
          localStorage.removeItem(RAEETSEL_STORAGE_KEY);
          // Reset all input cells
          document.querySelectorAll('input.cell:not(.black)').forEach(input => {
            input.value = '';
            input.style.backgroundColor = '';
          });
          // Save cleared state
          saveState();
        });

        // Rendert das Highlight und den Hinweis
        function internalRenderUI() {
          document.querySelectorAll("input.cell").forEach(i => i.classList.remove("highlight"));
          const w = words[currentWordIndex];
          currentDirection = w.horizontal ? 'horizontal' : 'vertical';
          for (let k = 0; k < w.word.length; k++) {
            const r = w.y + (w.horizontal ? 0 : k);
            const c = w.x + (w.horizontal ? k : 0);
            const cell = document.querySelector(`input.cell[data-row="${r}"][data-col="${c}"]`);
            if (cell) cell.classList.add("highlight");
          }
          document.getElementById("currentClue").textContent = w.clue;
        }

        // Erzeuge die Eingabefelder
        for (let row = 0; row < gridSize; row++) {
          for (let col = 0; col < gridSize; col++) {
            const input = document.createElement("input");
            input.classList.add("cell");
            input.maxLength = 1;
            if (grid[row][col] === null || grid[row][col] === "*") {
              input.classList.add("black");
              input.disabled = true;
            } else {
              input.dataset.row = row;
              input.dataset.col = col;
              const key = `${row},${col}`;
              if (saved && saved.userInputs && saved.userInputs[key]) {
                input.value = saved.userInputs[key];
              }
              // Mark user click
              input.addEventListener("mousedown", () => {
                userClicked = true;
              });
              // (Optional, f√ºr Zuverl√§ssigkeit auf allen Browsern) - oldValue-Update
              input.addEventListener("focus", () => { input.oldValue = input.value; });
              input.addEventListener("blur", () => { input.oldValue = ""; });
              input.addEventListener("input", () => { input.oldValue = input.value; });

              input.addEventListener("input", (e) => {
                // Immer NUR das zuletzt getippte Zeichen als Gro√übuchstabe √ºbernehmen
                if (e.data && e.data.length > 0) {
                  input.value = e.data.slice(-1).toUpperCase();
                } else if (input.value) {
                  input.value = input.value.slice(-1).toUpperCase();
                }
                let r = parseInt(input.dataset.row), c = parseInt(input.dataset.col);

                // Bestimme die Zellen im aktuellen Wort (damit wir wissen, ob es das letzte Feld ist)
                const w = words[currentWordIndex];
                let isLast = false;
                if (w.horizontal) {
                  isLast = (r === w.y && c === w.x + w.word.length - 1);
                } else {
                  isLast = (c === w.x && r === w.y + w.word.length - 1);
                }

                if (isLast) {
                  // Gehe automatisch zum n√§chsten Wort (erstes Feld)
                  currentWordIndex = (currentWordIndex + 1) % words.length;
                  const nw = words[currentWordIndex];
                  const first = document.querySelector(`input.cell[data-row="${nw.y}"][data-col="${nw.x}"]`);
                  if (first) {
                    first.focus();
                    lastFocusedCell = first;
                  }
                  internalRenderUI();
                } else {
                  // Weiter wie bisher zum n√§chsten Buchstaben im Wort springen
                  let next;
                  if (currentDirection === 'horizontal') {
                    c++;
                    next = document.querySelector(`input.cell[data-row="${r}"][data-col="${c}"]`);
                  } else {
                    r++;
                    next = document.querySelector(`input.cell[data-row="${r}"][data-col="${c}"]`);
                  }
                  if (next && next.classList.contains("highlight")) {
                    next.focus();
                  }
                }
                saveState();

                // Automatische Erfolgsmeldung wenn alles korrekt ausgef√ºllt ist
                checkAutoSuccess();
              });
              input.addEventListener("keydown", e => {
                if (e.key === "Backspace") {
                  let r = parseInt(input.dataset.row), c = parseInt(input.dataset.col);
                  if (input.value === "") {
                    // Gehe ein Feld zur√ºck und leere es
                    if (currentDirection === "horizontal") { c--; } else { r--; }
                    const prev = document.querySelector(`input.cell[data-row="${r}"][data-col="${c}"]`);
                    if (prev) {
                      prev.focus();
                      prev.value = "";
                      e.preventDefault();
                    }
                  } else {
                    // Nur das aktuelle Feld leeren (nicht springen)
                    input.value = "";
                    e.preventDefault();
                  }
                  saveState();
                }
              });
              // Nur auf echten Benutzerversuch reagieren: Wort wechseln bei Klick/Tab
              input.addEventListener("focus", event => {
                // Only respond to real user clicks
                if (!userClicked) return;
                userClicked = false;
                lastFocusedCell = input;
                const r = parseInt(input.dataset.row);
                const c = parseInt(input.dataset.col);
                // Finde alle W√∂rter, die diese Zelle enthalten
                const candidates = words.map((w, i) => {
                  if (w.horizontal && w.y === r && c >= w.x && c < w.x + w.word.length) return i;
                  if (!w.horizontal && w.x === c && r >= w.y && r < w.y + w.word.length) return i;
                  return null;
                }).filter(i => i !== null);
                if (candidates.length > 0) {
                  // W√§hle das Wort passend zur aktuellen Richtung oder das erste
                  const preferred = candidates.find(i => words[i].horizontal === currentDirection);
                  currentWordIndex = preferred !== undefined ? preferred : candidates[0];
                  internalRenderUI();
                }
              });
              // Leertaste im Eingabefeld: Nur bei Schnittpunkten Wort wechseln
              input.addEventListener("keydown", e => {
                if ((e.code === "Space" || e.key === " ") && !e.ctrlKey && !e.metaKey && !e.altKey) {
                  e.preventDefault();
                  // Wechsel nur, wenn Feld Teil von zwei W√∂rtern ist
                  const r = parseInt(input.dataset.row);
                  const c = parseInt(input.dataset.col);
                  const candidates = words.map((w, i) => {
                    if (w.horizontal && w.y === r && c >= w.x && c < w.x + w.word.length) return i;
                    if (!w.horizontal && w.x === c && r >= w.y && r < w.y + w.word.length) return i;
                    return null;
                  }).filter(i => i !== null);
                  if (candidates.length > 1) {
                    // Wechsel zum anderen Wort
                    const other = candidates.find(i => i !== currentWordIndex);
                    if (other !== undefined) {
                      currentWordIndex = other;
                      internalRenderUI();
                    }
                  }
                }
              });
            }
            input.style.gridColumnStart = col + 1;
            input.style.gridRowStart = row + 1;
            gridContainer.appendChild(input);
          }
        }

        // Prev/Next & Leertaste zur Navigation
        document.getElementById("prevWord").addEventListener("click", () => {
          currentWordIndex = (currentWordIndex - 1 + words.length) % words.length;
          internalRenderUI();
          saveState();
        });
        document.getElementById("nextWord").addEventListener("click", () => {
          currentWordIndex = (currentWordIndex + 1) % words.length;
          internalRenderUI();
          saveState();
        });
        document.addEventListener("keydown", e => {
          if (e.code === "Space") {
            e.preventDefault();
            currentDirection = currentDirection === 'horizontal' ? 'vertical' : 'horizontal';
            // Wechsle Wort, falls die aktuelle Zelle zwei Optionen bietet
            if (lastFocusedCell) {
              const r = parseInt(lastFocusedCell.dataset.row);
              const c = parseInt(lastFocusedCell.dataset.col);
              const candidates = words.map((w, i) => {
                if (w.horizontal && w.y === r && c >= w.x && c < w.x + w.word.length) return i;
                if (!w.horizontal && w.x === c && r >= w.y && r < w.y + w.word.length) return i;
                return null;
              }).filter(i => i !== null);
              const preferred = candidates.find(i => words[i].horizontal === currentDirection);
              if (preferred !== undefined) {
                currentWordIndex = preferred;
              }
            }
            internalRenderUI();
          } else if (e.code === "ArrowRight") {
            currentWordIndex = (currentWordIndex + 1) % words.length;
            internalRenderUI();
            // Fokus auf das erste Feld des neuen Wortes setzen
            const wRight = words[currentWordIndex];
            const startRight = document.querySelector(`input.cell[data-row="${wRight.y}"][data-col="${wRight.x}"]`);
            if (startRight) startRight.focus();
          } else if (e.code === "ArrowLeft") {
            currentWordIndex = (currentWordIndex - 1 + words.length) % words.length;
            internalRenderUI();
            // Fokus auf das erste Feld des neuen Wortes setzen
            const wLeft = words[currentWordIndex];
            const startLeft = document.querySelector(`input.cell[data-row="${wLeft.y}"][data-col="${wLeft.x}"]`);
            if (startLeft) startLeft.focus();
          }
        });

        // Initial
        internalRenderUI();
        // Auto-Fokus auf das erste Wort
        const w0 = words[currentWordIndex];
        const start0 = document.querySelector(`input.cell[data-row="${w0.y}"][data-col="${w0.x}"]`);
        if (start0) {
          start0.focus();
          lastFocusedCell = start0;
        }
        puzzleStart = performance.now();
        updateUserHud();
        // Flag button handler
        document.getElementById('flagBtn').addEventListener('click', () => {
          if (!currentWordIndex && currentWordIndex !== 0) return;
          const w = words[currentWordIndex];
          fetch('/api/flag', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ puzzle: puzzleType, word: w.word, id: w.id })
          })
          .then(() => alert('Dieses Wort wurde gemeldet.'))
          .catch(() => alert('Fehler beim Melden des Wortes.'));
        });

      })
      .catch(err => console.error("Fehler beim Laden der Wortliste:", err));
    window.addEventListener("beforeunload", saveState);
  </script>
  <footer class="footer">
    <button id="impressumBtn" onclick="window.location.href='impressum.html'">Impressum</button>
  </footer>
  <div id="confetti-container"></div>
</body>
</html>
